---
title: "80-20 rule for learning Nim"
date: 2022-10-24T00:03:30+01:00
draft: false
---

aka Pareto principle.

After writing Python for over 10 years, I can code in it as naturally as I speak Spanish or English. The honeymoon period is over, though. Python has some disadvantages I'm no longer willing to tolerate:

1. **Distribution complexity**: Sharing code requires the right interpreter + pip registry access on target environments. Air-gapped environments become nightmares. Tools like nuitka exist, but adoption remains limited.
2. **Performance bottlenecks**: Python is slow. NumPy and Numba help, but then you're back to problem #1 with dependency management.
3. **The Zen contradiction**: "There should be one obvious way to do it." Right. Sure.

I considered three languages for my transition:

- **Go**: Simple, fast, but verbose. Excellent for infrastructure but feels rigid.
- **Rust**: Blazing fast, memory safe, but the learning curve is steep. Ownership semantics require significant mental model shifts.
- **Nim**: Fast compilation, Python-like syntax, systems programming capabilities with scripting language ergonomics.

I chose Nim. Fast enough for systems work, familiar enough to maintain productivity during transition.

## Applying the 80-20 Principle

The Pareto principle suggests 80% of results come from 20% of efforts. For language transitions, this means identifying the core patterns that handle most real-world scenarios. Instead of learning everything, focus on the essential subset that covers your daily programming needs.

Here are the six areas that constitute the critical 20% for my Python-to-Nim transition:

## 1. JSON/YAML Manipulation

This handles configuration, API responses, and data interchange. In Python, you probably use `json` and `PyYAML`:

```python
# Python
import json
import yaml

data = {"name": "memo", "role": "engineer"}
json_str = json.dumps(data)
config = yaml.safe_load(open("config.yaml"))
```

Nim's approach is similarly straightforward:

```nim
# Nim
import json, yaml

let data = %*{"name": "memo", "role": "engineer"}
let jsonStr = $data
let config = loadYaml("config.yaml")
```

The `%*` operator creates JSON nodes. The `$` operator converts to string representation. Clean and familiar.

## 2. HTTP Requests

APIs are everywhere. Python's `requests` library set the standard for ergonomics:

```python
# Python
import requests

response = requests.get("https://api.github.com/users/memo")
data = response.json()
print(f"Status: {response.status_code}")
```

Nim offers multiple HTTP clients. The stdlib's `httpclient` works well:

```nim
# Nim
import httpclient, json

let client = newHttpClient()
let response = client.get("https://api.github.com/users/memo")
let data = parseJson(response.body)
echo "Status: ", response.status
```

For async operations, Nim's `asynchttpclient` provides similar patterns to Python's `aiohttp`.

## 3. String/File Manipulation

Text processing drives most automation scripts. Python makes this trivial:

```python
# Python
with open("data.txt") as f:
    content = f.read()
    
lines = content.strip().split("\n")
filtered = [line for line in lines if line.startswith("ERROR")]
```

Nim provides comparable convenience:

```nim
# Nim
let content = readFile("data.txt")
let lines = content.strip().split("\n")
let filtered = lines.filter(proc(line: string): bool = line.startsWith("ERROR"))
```

Nim's `strutils` module includes most string operations you'd expect. File I/O feels natural coming from Python.

## 4. Gluing Services Together

This is more complex than it sounds. You're building small utilities that connect different systems, transform data formats, and handle failures gracefully.

Python excels here with its extensive ecosystem:

```python
# Python - service integration script
import requests
import time
from typing import Dict, Any

def sync_users(source_api: str, target_api: str) -> Dict[str, Any]:
    try:
        users = requests.get(f"{source_api}/users").json()
        results = []
        
        for user in users:
            transformed = {
                "id": user["user_id"],
                "email": user["email_address"], 
                "active": user["status"] == "enabled"
            }
            
            response = requests.post(f"{target_api}/users", json=transformed)
            results.append({"id": user["user_id"], "success": response.ok})
            time.sleep(0.1)  # Rate limiting
            
        return {"synced": len(results), "details": results}
    except Exception as e:
        return {"error": str(e)}
```

Nim handles this type of integration work well:

```nim
# Nim - service integration
import httpclient, json, times, tables

type
  SyncResult = object
    synced: int
    details: seq[Table[string, JsonNode]]

proc syncUsers(sourceApi: string, targetApi: string): SyncResult =
  let client = newHttpClient()
  
  try:
    let usersResponse = client.get(sourceApi & "/users")
    let users = parseJson(usersResponse.body)
    var results: seq[Table[string, JsonNode]]
    
    for user in users:
      let transformed = %*{
        "id": user["user_id"],
        "email": user["email_address"],
        "active": user["status"].getStr() == "enabled"
      }
      
      let response = client.post(targetApi & "/users", body = $transformed)
      results.add({"id": user["user_id"], "success": %response.status.is2xx}.toTable)
      sleep(100) # Rate limiting - 100ms
      
    result = SyncResult(synced: results.len, details: results)
  except:
    result = SyncResult(synced: 0, details: @[])
```

## 5. Debugging

Python's debugging story is mature: `pdb`, `ipdb`, IDE integration, and `print()` debugging.

Nim provides similar capabilities:

```nim
# Nim debugging approaches
import logging

# Simple debug output
echo "Debug: processing user ", userId

# Logging with levels
let logger = newConsoleLogger()
logger.log(lvlDebug, "Starting user sync")

# Assertions for development
assert userId > 0, "User ID must be positive"

# GDB integration works well for compiled binaries
# nim c --debuginfo --linedir:on myprogram.nim
```

The `--debuginfo` flag generates debugging symbols. GDB and LLDB work with Nim binaries. For rapid iteration, `echo` statements remain effective.

## 6. Web Servers

Building HTTP APIs and simple web services covers many use cases. Python offers Django, Flask, FastAPI, and others.

Nim's ecosystem provides several options. Here's a simple API with Jester (Nim's Sinatra-like framework):

```nim
# Nim web server with Jester
import jester, json

routes:
  get "/":
    resp "Hello, World!"
    
  get "/users/@id":
    let userId = @"id"
    let userData = %*{"id": userId, "name": "User " & userId}
    resp userData, Http200
    
  post "/users":
    let body = parseJson(request.body)
    # Process user creation
    resp %*{"status": "created", "id": 123}, Http201

runForever()
```

For more complex applications, Nim offers Prologue (Rails-inspired) and other frameworks.

## The Learning Curve Reality

Transitioning between languages isn't just about syntax mapping. It's about understanding idioms, ecosystem conventions, and tooling differences.

**What transfers easily from Python:**
- Sequence operations (map, filter, reduce patterns)
- String manipulation mental models
- File I/O approaches
- HTTP client usage patterns

**What requires adjustment:**
- Static typing (though Nim's type inference helps)
- Compilation step in development workflow
- Memory management awareness (though Nim handles most of it)
- Package management differences (Nimble vs pip)

**Performance surprises:**
Binary sizes are tiny compared to Python distributions. A simple HTTP client binary might be 200KB versus a 50MB Python environment. Startup times drop from hundreds of milliseconds to single-digit milliseconds.

## Beyond the 80%

The remaining 80% of Nim includes metaprogramming, unsafe operations, C interoperability, and advanced type system features. You don't need these immediately. Focus on the core patterns first.

The 80-20 principle works because most programming tasks follow similar patterns: read data, transform it, write results somewhere else. Master these fundamentals in your new language, then expand gradually.

**Practical next steps:**
1. Set up your development environment (Nim, Nimble, VS Code extension)
2. Rewrite a small Python utility in Nim
3. Build something that touches all six areas above
4. Read other people's Nim code on GitHub
5. Join the Nim community forum for questions

The goal isn't to become a Nim expert immediately. It's to become productive enough that Nim feels like a viable alternative to Python for your daily programming needs.

Some projects work better in Python. Some work better in Nim. Having both tools available expands your options for solving problems effectively.

```
Python: Great for → Data science, ML, rapid prototyping, glue scripts
Nim:    Great for → CLI tools, web services, system utilities, performance-critical code
```

The 80-20 rule helped me focus on practical application over comprehensive study. Six months later, I'm writing Nim code almost as naturally as Python. The honeymoon period might be starting again.
