<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Keycloak: Identity Management | Memo Garcia</title>
<meta name=keywords content><meta name=description content="Implementing authentication from scratch often starts simple but quickly escalates into weeks of navigating RFC specifications and protocol implementations. Keycloak addresses this complexity by providing a comprehensive identity management solution.
What is Keycloak? Keycloak is an open-source identity and access management solution that handles authentication and authorization at enterprise scale.
Core capabilities include:
Single Sign-On (SSO) - Centralized authentication across multiple applications User federation - Integration with LDAP, Active Directory, and other identity stores Identity brokering - Authentication through external providers including Google, GitHub, and SAML systems Authorization policies - Fine-grained permission management Standard protocols - OAuth 2."><link rel=canonical href=https://memo.mx/posts/keycloak-identity-management/><meta name=google-site-verification content="G-ZRB1GGCC9B"><link crossorigin=anonymous href=/assets/css/stylesheet.d1467e28595903f993a7e37893057cefe5f69aece461c850796bf5b0a3bf422a.css integrity="sha256-0UZ+KFlZA/mTp+N4kwV87+X2muzkYchQeWv1sKO/Qio=" rel="preload stylesheet" as=style><link rel=icon href=https://memo.mx/%20favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://memo.mx/%20favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://memo.mx/%20favicon-32x32.png><link rel=apple-touch-icon href=https://memo.mx/%20apple-touch-icon.png><link rel=mask-icon href=https://memo.mx/%20safari-pinned-tab.svg><meta name=theme-color content="#0d0221"><meta name=msapplication-TileColor content="#0d0221"><link rel=alternate hreflang=en href=https://memo.mx/posts/keycloak-identity-management/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZRB1GGCC9B"></script><script>var dnt,doNotTrack=!1;if(!0&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZRB1GGCC9B")}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://memo.mx/posts/"},{"@type":"ListItem","position":2,"name":"Keycloak: Identity Management","item":"https://memo.mx/posts/keycloak-identity-management/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Keycloak: Identity Management","name":"Keycloak: Identity Management","description":"Implementing authentication from scratch often starts simple but quickly escalates into weeks of navigating RFC specifications and protocol implementations. Keycloak addresses this complexity by providing a comprehensive identity management solution.\nWhat is Keycloak? Keycloak is an open-source identity and access management solution that handles authentication and authorization at enterprise scale.\nCore capabilities include:\nSingle Sign-On (SSO) - Centralized authentication across multiple applications User federation - Integration with LDAP, Active Directory, and other identity stores Identity brokering - Authentication through external providers including Google, GitHub, and SAML systems Authorization policies - Fine-grained permission management Standard protocols - OAuth 2.","keywords":[],"articleBody":"Implementing authentication from scratch often starts simple but quickly escalates into weeks of navigating RFC specifications and protocol implementations. Keycloak addresses this complexity by providing a comprehensive identity management solution.\nWhat is Keycloak? Keycloak is an open-source identity and access management solution that handles authentication and authorization at enterprise scale.\nCore capabilities include:\nSingle Sign-On (SSO) - Centralized authentication across multiple applications User federation - Integration with LDAP, Active Directory, and other identity stores Identity brokering - Authentication through external providers including Google, GitHub, and SAML systems Authorization policies - Fine-grained permission management Standard protocols - OAuth 2.0, OpenID Connect, and SAML 2.0 support Keycloak acts as a centralized authentication service that manages user identities and access policies while your applications focus on business logic.\nIdentity Providers and Federation Keycloak’s federation capabilities eliminate the need for users to create separate accounts for each application. It integrates with existing identity systems seamlessly.\nSupported authentication methods include:\nCorporate Active Directory credentials Google or GitHub accounts External SAML providers Custom LDAP directories Any system supporting standard authentication protocols Keycloak acts as a protocol translator, converting various authentication methods into standardized tokens your application can consume. Whether users authenticate through Google OAuth or legacy LDAP servers, your application receives a consistent, standard token containing necessary user information.\nThis abstraction layer means your frontend doesn’t need to handle the complexity of different token formats like SAML assertions or JWT tokens. It simply receives confirmation of authentication and user details in a standardized format.\nCore Concepts: Realms, Tenants, Projects Understanding Keycloak’s terminology is essential, as different systems often use different terms for similar concepts.\nRealms in Keycloak represent complete identity domains. Each realm has its own:\nUsers and groups Identity providers Client applications Security policies Realms provide complete isolation. Users in one realm cannot access or view users in another realm, effectively creating separate identity systems on the same Keycloak instance.\nCommon architectural patterns include:\nOne realm per organization - Suitable for multi-tenant SaaS applications One realm per environment - Provides dev/staging/production isolation One realm per project - Ensures complete separation between teams The optimal approach depends on your specific isolation requirements and complexity tolerance.\nUsers, Clients, and Applications Users represent entities requiring authentication, including both people and services.\nClients in Keycloak terminology refer to any application requiring user authentication. This encompasses:\nWeb applications Mobile applications Backend services and microservices Third-party integrations Each client requires specific configuration:\nAuthentication flow - Distinguishing between public clients and confidential clients Redirect URIs - Specifying post-authentication redirect destinations Token settings - Configuring token lifespan and content Access permissions - Defining client capabilities and restrictions Client IDs vs Application IDs Different OAuth providers use varying terminology for the same concept, which can create confusion.\nKeycloak uses Client ID, while Azure AD uses Application ID. OAuth 1.0 referred to this as a Consumer Key, and some APIs simply call it an API Key.\nThese terms all represent the same fundamental concept: a unique identifier that identifies your application to the identity provider. Think of it as your application’s username.\nUnderstanding the underlying concept is more important than memorizing platform-specific terminology, though knowing these differences aids in cross-platform debugging.\nPractical Implementation Scenarios Here are concrete examples demonstrating Keycloak deployment patterns.\nScenario 1: Corporate SSO Multiple internal applications requiring unified authentication.\nConfigure a Keycloak realm Integrate with Active Directory Register each application as a client Enable single sign-on across all applications Scenario 2: Enterprise SaaS Integration Customers requiring integration with their existing identity systems using various protocols.\nConfigure identity providers for each customer’s protocol (SAML, OIDC, etc.) Enable authentication using existing corporate credentials Transform diverse authentication methods into your application’s user model Maintain application-level abstraction from authentication complexity Scenario 3: Microservices Architecture Multiple services requiring shared authentication and authorization context.\nFrontend authenticates with Keycloak using standard OAuth flow Receives JWT token containing user information and permissions Includes token in requests to backend services Services perform local token validation This approach eliminates the need for services to contact Keycloak for each request. JWT tokens are self-contained, including all necessary validation data.\nAdvanced Authorization with OPA and Keycloak While Keycloak handles authentication effectively, complex authorization decisions often require more sophisticated policy evaluation. Open Policy Agent (OPA) complements Keycloak by providing fine-grained, context-aware authorization.\nArchitecture Overview The integration typically follows this pattern:\n┌─────────────┐ │ User │ └──────┬──────┘ │ 1. Login ▼ ┌─────────────────────────────────────────────┐ │ Keycloak │ │ ┌─────────┐ ┌──────────┐ ┌──────────┐ │ │ │ Realm │ │ Users │ │ IdP │ │ │ └─────────┘ └──────────┘ └──────────┘ │ └─────────────────────┬───────────────────────┘ │ 2. JWT Token ┌──────────────┴──────────────┐ ▼ ▼ ┌──────────────┐ ┌──────────────┐ │ Frontend │ │ Service A │ │ Application │ │ │ └──────┬───────┘ │ ┌────────┐ │ │ 3. API Request │ │ OPA │ │ │ + JWT │ │Sidecar │ │ ▼ │ └────┬───┘ │ ┌──────────────────────┐ └───────┼──────┘ │ API Gateway │ │ 5. Decision │ │ ▼ │ ┌──────────────┐ │ ┌──────────────┐ │ │ JWT Validation│ │ │ Service B │ │ └──────────────┘ │ │ │ └──────────┬───────────┘ │ ┌────────┐ │ │ 4. Forward │ │ OPA │ │ │ Request │ │Sidecar │ │ ▼ │ └────┬───┘ │ ┌──────────────┐ └───────┼──────┘ │ Services │ │ │ │ ▼ │ ┌──────────┐ │ ┌──────────────┐ │ │ OPA │ │ │ Database │ │ │ Library │ │ └──────────────┘ │ └──────────┘ │ └──────────────┘ Keycloak manages authentication and issues JWT tokens containing user identity and basic roles OPA evaluates authorization policies based on the JWT claims plus additional context Services query OPA for authorization decisions using the JWT and request context Implementation Pattern A typical service authorization flow:\n1. User authenticates with Keycloak → receives JWT 2. User requests resource from service 3. Service extracts JWT claims 4. Service queries OPA with: - JWT claims (user, roles, groups) - Resource being accessed - Action being performed - Additional context (time, location, etc.) 5. OPA evaluates policies and returns allow/deny decision 6. Service proceeds based on OPA's decision Policy Examples OPA policies can express complex authorization logic that would be difficult to implement in Keycloak alone:\nResource-based access control:\nUsers can only access resources in their department Managers can approve requests up to their spending limit Documents are accessible based on classification level and user clearance Contextual authorization:\nCertain operations only allowed during business hours Geographic restrictions based on user location Rate limiting based on user tier Dynamic policy evaluation:\nPolicies updated without redeploying services A/B testing of authorization rules Gradual rollout of new access controls Integration Benefits Combining Keycloak with OPA provides:\nSeparation of concerns - Authentication (Keycloak) separate from authorization (OPA) Policy as code - Authorization rules version-controlled and tested Decoupled authorization - Services don’t embed authorization logic Unified policy language - Rego policies work across all services Performance - OPA decisions cached locally, no network calls required Practical Considerations When implementing OPA with Keycloak:\nToken enrichment - Configure Keycloak to include necessary claims in JWTs (groups, departments, attributes) Policy distribution - Establish how OPA instances receive policy updates (bundle service, git sync, CI/CD) Decision logging - Capture authorization decisions for audit and debugging Performance tuning - Cache OPA decisions appropriately for your use case Testing strategy - Unit test Rego policies independently from services Example Setup A microservices environment might deploy OPA as:\nSidecar pattern - OPA container alongside each service Centralized service - Shared OPA cluster for all services Library integration - OPA embedded as a library in service code Each approach has trade-offs in terms of latency, consistency, and operational complexity.\nWhen to Use Keycloak Keycloak is appropriate when:\nSSO is required across multiple applications Users exist in external systems like LDAP or Active Directory Microservices architecture requires shared identity context Compliance requirements demand audit trails and fine-grained permissions Standard protocol support is needed without custom implementation Consider alternatives when:\nBuilding simple single applications with basic authentication needs Preferring managed services like Auth0 or Okta over self-hosted infrastructure Basic authentication meets all project requirements Understanding Identity Management Complexity Identity management is critical infrastructure that users only notice when it fails. Keycloak addresses real authentication challenges but requires understanding of OAuth flows, token validation, and session management. The advantage lies in configuring proven software rather than building from scratch.\nTeams often underestimate authentication complexity, spending months on custom systems before discovering additional protocol requirements. Conversely, some over-engineer solutions for simple use cases better served by basic authentication.\nSuccess depends on accurately identifying your actual requirements and choosing appropriate solutions.\nKey Considerations for Identity Infrastructure Treating identity as infrastructure requires:\nScalability planning - Simple user tables quickly become inadequate Comprehensive testing - Authentication bugs represent security vulnerabilities Continuous monitoring - Track both failed and successful authentication attempts Simplicity focus - Custom integrations accumulate as technical debt Keycloak handles the complex authentication challenges that most teams shouldn’t build themselves. Avoiding custom OAuth implementations saves significant development time and reduces security risks.\n","wordCount":"1466","inLanguage":"en","datePublished":"2025-08-13T00:00:00+01:00","dateModified":"2025-09-03T21:26:46+09:00","author":{"@type":"Person","name":"Memo Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://memo.mx/posts/keycloak-identity-management/"},"publisher":{"@type":"Person","name":"Memo Garcia","logo":{"@type":"ImageObject","url":"https://memo.mx/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://memo.mx/ accesskey=h title="Memo Garcia (Alt + H)">Memo Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://memo.mx/books title=Books><span>Books</span></a></li><li><a href=https://memo.mx/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Keycloak: Identity Management</h1><div class=post-meta><span title='2025-08-13 00:00:00 +0100 +0100'>August 13, 2025</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Memo Garcia</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-is-keycloak aria-label="What is Keycloak?">What is Keycloak?</a></li><li><a href=#identity-providers-and-federation aria-label="Identity Providers and Federation">Identity Providers and Federation</a></li><li><a href=#core-concepts-realms-tenants-projects aria-label="Core Concepts: Realms, Tenants, Projects">Core Concepts: Realms, Tenants, Projects</a></li><li><a href=#users-clients-and-applications aria-label="Users, Clients, and Applications">Users, Clients, and Applications</a></li><li><a href=#client-ids-vs-application-ids aria-label="Client IDs vs Application IDs">Client IDs vs Application IDs</a></li><li><a href=#practical-implementation-scenarios aria-label="Practical Implementation Scenarios">Practical Implementation Scenarios</a></li><li><a href=#advanced-authorization-with-opa-and-keycloak aria-label="Advanced Authorization with OPA and Keycloak">Advanced Authorization with OPA and Keycloak</a><ul><li><a href=#architecture-overview aria-label="Architecture Overview">Architecture Overview</a></li><li><a href=#implementation-pattern aria-label="Implementation Pattern">Implementation Pattern</a></li><li><a href=#policy-examples aria-label="Policy Examples">Policy Examples</a></li><li><a href=#integration-benefits aria-label="Integration Benefits">Integration Benefits</a></li><li><a href=#practical-considerations aria-label="Practical Considerations">Practical Considerations</a></li><li><a href=#example-setup aria-label="Example Setup">Example Setup</a></li></ul></li><li><a href=#when-to-use-keycloak aria-label="When to Use Keycloak">When to Use Keycloak</a></li><li><a href=#understanding-identity-management-complexity aria-label="Understanding Identity Management Complexity">Understanding Identity Management Complexity</a></li><li><a href=#key-considerations-for-identity-infrastructure aria-label="Key Considerations for Identity Infrastructure">Key Considerations for Identity Infrastructure</a></li></ul></div></details></div><div class=post-content><p>Implementing authentication from scratch often starts simple but quickly escalates into weeks of navigating RFC specifications and protocol implementations. Keycloak addresses this complexity by providing a comprehensive identity management solution.</p><h2 id=what-is-keycloak>What is Keycloak?<a hidden class=anchor aria-hidden=true href=#what-is-keycloak>#</a></h2><p>Keycloak is an open-source identity and access management solution that handles authentication and authorization at enterprise scale.</p><p>Core capabilities include:</p><ul><li><strong>Single Sign-On (SSO)</strong> - Centralized authentication across multiple applications</li><li><strong>User federation</strong> - Integration with LDAP, Active Directory, and other identity stores</li><li><strong>Identity brokering</strong> - Authentication through external providers including Google, GitHub, and SAML systems</li><li><strong>Authorization policies</strong> - Fine-grained permission management</li><li><strong>Standard protocols</strong> - OAuth 2.0, OpenID Connect, and SAML 2.0 support</li></ul><p>Keycloak acts as a centralized authentication service that manages user identities and access policies while your applications focus on business logic.</p><h2 id=identity-providers-and-federation>Identity Providers and Federation<a hidden class=anchor aria-hidden=true href=#identity-providers-and-federation>#</a></h2><p>Keycloak&rsquo;s federation capabilities eliminate the need for users to create separate accounts for each application. It integrates with existing identity systems seamlessly.</p><p>Supported authentication methods include:</p><ul><li>Corporate Active Directory credentials</li><li>Google or GitHub accounts</li><li>External SAML providers</li><li>Custom LDAP directories</li><li>Any system supporting standard authentication protocols</li></ul><p>Keycloak acts as a protocol translator, converting various authentication methods into standardized tokens your application can consume. Whether users authenticate through Google OAuth or legacy LDAP servers, your application receives a consistent, standard token containing necessary user information.</p><p>This abstraction layer means your frontend doesn&rsquo;t need to handle the complexity of different token formats like SAML assertions or JWT tokens. It simply receives confirmation of authentication and user details in a standardized format.</p><h2 id=core-concepts-realms-tenants-projects>Core Concepts: Realms, Tenants, Projects<a hidden class=anchor aria-hidden=true href=#core-concepts-realms-tenants-projects>#</a></h2><p>Understanding Keycloak&rsquo;s terminology is essential, as different systems often use different terms for similar concepts.</p><p><strong>Realms</strong> in Keycloak represent complete identity domains. Each realm has its own:</p><ul><li>Users and groups</li><li>Identity providers</li><li>Client applications</li><li>Security policies</li></ul><p>Realms provide complete isolation. Users in one realm cannot access or view users in another realm, effectively creating separate identity systems on the same Keycloak instance.</p><p>Common architectural patterns include:</p><ul><li><strong>One realm per organization</strong> - Suitable for multi-tenant SaaS applications</li><li><strong>One realm per environment</strong> - Provides dev/staging/production isolation</li><li><strong>One realm per project</strong> - Ensures complete separation between teams</li></ul><p>The optimal approach depends on your specific isolation requirements and complexity tolerance.</p><h2 id=users-clients-and-applications>Users, Clients, and Applications<a hidden class=anchor aria-hidden=true href=#users-clients-and-applications>#</a></h2><p><strong>Users</strong> represent entities requiring authentication, including both people and services.</p><p><strong>Clients</strong> in Keycloak terminology refer to any application requiring user authentication. This encompasses:</p><ul><li>Web applications</li><li>Mobile applications</li><li>Backend services and microservices</li><li>Third-party integrations</li></ul><p>Each client requires specific configuration:</p><ul><li><strong>Authentication flow</strong> - Distinguishing between public clients and confidential clients</li><li><strong>Redirect URIs</strong> - Specifying post-authentication redirect destinations</li><li><strong>Token settings</strong> - Configuring token lifespan and content</li><li><strong>Access permissions</strong> - Defining client capabilities and restrictions</li></ul><h2 id=client-ids-vs-application-ids>Client IDs vs Application IDs<a hidden class=anchor aria-hidden=true href=#client-ids-vs-application-ids>#</a></h2><p>Different OAuth providers use varying terminology for the same concept, which can create confusion.</p><p>Keycloak uses <strong>Client ID</strong>, while Azure AD uses <strong>Application ID</strong>. OAuth 1.0 referred to this as a <strong>Consumer Key</strong>, and some APIs simply call it an <strong>API Key</strong>.</p><p>These terms all represent the same fundamental concept: a unique identifier that identifies your application to the identity provider. Think of it as your application&rsquo;s username.</p><p>Understanding the underlying concept is more important than memorizing platform-specific terminology, though knowing these differences aids in cross-platform debugging.</p><h2 id=practical-implementation-scenarios>Practical Implementation Scenarios<a hidden class=anchor aria-hidden=true href=#practical-implementation-scenarios>#</a></h2><p>Here are concrete examples demonstrating Keycloak deployment patterns.</p><p><strong>Scenario 1: Corporate SSO</strong>
Multiple internal applications requiring unified authentication.</p><ol><li>Configure a Keycloak realm</li><li>Integrate with Active Directory</li><li>Register each application as a client</li><li>Enable single sign-on across all applications</li></ol><p><strong>Scenario 2: Enterprise SaaS Integration</strong>
Customers requiring integration with their existing identity systems using various protocols.</p><ol><li>Configure identity providers for each customer&rsquo;s protocol (SAML, OIDC, etc.)</li><li>Enable authentication using existing corporate credentials</li><li>Transform diverse authentication methods into your application&rsquo;s user model</li><li>Maintain application-level abstraction from authentication complexity</li></ol><p><strong>Scenario 3: Microservices Architecture</strong>
Multiple services requiring shared authentication and authorization context.</p><ol><li>Frontend authenticates with Keycloak using standard OAuth flow</li><li>Receives JWT token containing user information and permissions</li><li>Includes token in requests to backend services</li><li>Services perform local token validation</li></ol><p>This approach eliminates the need for services to contact Keycloak for each request. JWT tokens are self-contained, including all necessary validation data.</p><h2 id=advanced-authorization-with-opa-and-keycloak>Advanced Authorization with OPA and Keycloak<a hidden class=anchor aria-hidden=true href=#advanced-authorization-with-opa-and-keycloak>#</a></h2><p>While Keycloak handles authentication effectively, complex authorization decisions often require more sophisticated policy evaluation. Open Policy Agent (OPA) complements Keycloak by providing fine-grained, context-aware authorization.</p><h3 id=architecture-overview>Architecture Overview<a hidden class=anchor aria-hidden=true href=#architecture-overview>#</a></h3><p>The integration typically follows this pattern:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌─────────────┐
</span></span><span class=line><span class=cl>│    User     │
</span></span><span class=line><span class=cl>└──────┬──────┘
</span></span><span class=line><span class=cl>       │ 1. Login
</span></span><span class=line><span class=cl>       ▼
</span></span><span class=line><span class=cl>┌─────────────────────────────────────────────┐
</span></span><span class=line><span class=cl>│                 Keycloak                     │
</span></span><span class=line><span class=cl>│  ┌─────────┐  ┌──────────┐  ┌──────────┐   │
</span></span><span class=line><span class=cl>│  │  Realm  │  │   Users  │  │   IdP    │   │
</span></span><span class=line><span class=cl>│  └─────────┘  └──────────┘  └──────────┘   │
</span></span><span class=line><span class=cl>└─────────────────────┬───────────────────────┘
</span></span><span class=line><span class=cl>                      │ 2. JWT Token
</span></span><span class=line><span class=cl>       ┌──────────────┴──────────────┐
</span></span><span class=line><span class=cl>       ▼                             ▼
</span></span><span class=line><span class=cl>┌──────────────┐              ┌──────────────┐
</span></span><span class=line><span class=cl>│   Frontend   │              │   Service A   │
</span></span><span class=line><span class=cl>│ Application  │              │              │
</span></span><span class=line><span class=cl>└──────┬───────┘              │  ┌────────┐  │
</span></span><span class=line><span class=cl>       │ 3. API Request       │  │  OPA   │  │
</span></span><span class=line><span class=cl>       │    + JWT             │  │Sidecar │  │
</span></span><span class=line><span class=cl>       ▼                      │  └────┬───┘  │
</span></span><span class=line><span class=cl>┌──────────────────────┐      └───────┼──────┘
</span></span><span class=line><span class=cl>│     API Gateway      │              │ 5. Decision
</span></span><span class=line><span class=cl>│                      │              ▼
</span></span><span class=line><span class=cl>│  ┌──────────────┐    │      ┌──────────────┐
</span></span><span class=line><span class=cl>│  │ JWT Validation│   │      │   Service B   │
</span></span><span class=line><span class=cl>│  └──────────────┘    │      │              │
</span></span><span class=line><span class=cl>└──────────┬───────────┘      │  ┌────────┐  │
</span></span><span class=line><span class=cl>           │ 4. Forward       │  │  OPA   │  │
</span></span><span class=line><span class=cl>           │    Request       │  │Sidecar │  │
</span></span><span class=line><span class=cl>           ▼                  │  └────┬───┘  │
</span></span><span class=line><span class=cl>    ┌──────────────┐          └───────┼──────┘
</span></span><span class=line><span class=cl>    │   Services   │                  │
</span></span><span class=line><span class=cl>    │              │                  ▼
</span></span><span class=line><span class=cl>    │ ┌──────────┐ │          ┌──────────────┐
</span></span><span class=line><span class=cl>    │ │   OPA    │ │          │   Database   │
</span></span><span class=line><span class=cl>    │ │ Library  │ │          └──────────────┘
</span></span><span class=line><span class=cl>    │ └──────────┘ │
</span></span><span class=line><span class=cl>    └──────────────┘
</span></span></code></pre></div><ol><li><strong>Keycloak</strong> manages authentication and issues JWT tokens containing user identity and basic roles</li><li><strong>OPA</strong> evaluates authorization policies based on the JWT claims plus additional context</li><li><strong>Services</strong> query OPA for authorization decisions using the JWT and request context</li></ol><h3 id=implementation-pattern>Implementation Pattern<a hidden class=anchor aria-hidden=true href=#implementation-pattern>#</a></h3><p>A typical service authorization flow:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1. User authenticates with Keycloak → receives JWT
</span></span><span class=line><span class=cl>2. User requests resource from service
</span></span><span class=line><span class=cl>3. Service extracts JWT claims
</span></span><span class=line><span class=cl>4. Service queries OPA with:
</span></span><span class=line><span class=cl>   - JWT claims (user, roles, groups)
</span></span><span class=line><span class=cl>   - Resource being accessed
</span></span><span class=line><span class=cl>   - Action being performed
</span></span><span class=line><span class=cl>   - Additional context (time, location, etc.)
</span></span><span class=line><span class=cl>5. OPA evaluates policies and returns allow/deny decision
</span></span><span class=line><span class=cl>6. Service proceeds based on OPA&#39;s decision
</span></span></code></pre></div><h3 id=policy-examples>Policy Examples<a hidden class=anchor aria-hidden=true href=#policy-examples>#</a></h3><p>OPA policies can express complex authorization logic that would be difficult to implement in Keycloak alone:</p><p><strong>Resource-based access control:</strong></p><ul><li>Users can only access resources in their department</li><li>Managers can approve requests up to their spending limit</li><li>Documents are accessible based on classification level and user clearance</li></ul><p><strong>Contextual authorization:</strong></p><ul><li>Certain operations only allowed during business hours</li><li>Geographic restrictions based on user location</li><li>Rate limiting based on user tier</li></ul><p><strong>Dynamic policy evaluation:</strong></p><ul><li>Policies updated without redeploying services</li><li>A/B testing of authorization rules</li><li>Gradual rollout of new access controls</li></ul><h3 id=integration-benefits>Integration Benefits<a hidden class=anchor aria-hidden=true href=#integration-benefits>#</a></h3><p>Combining Keycloak with OPA provides:</p><ul><li><strong>Separation of concerns</strong> - Authentication (Keycloak) separate from authorization (OPA)</li><li><strong>Policy as code</strong> - Authorization rules version-controlled and tested</li><li><strong>Decoupled authorization</strong> - Services don&rsquo;t embed authorization logic</li><li><strong>Unified policy language</strong> - Rego policies work across all services</li><li><strong>Performance</strong> - OPA decisions cached locally, no network calls required</li></ul><h3 id=practical-considerations>Practical Considerations<a hidden class=anchor aria-hidden=true href=#practical-considerations>#</a></h3><p>When implementing OPA with Keycloak:</p><ol><li><strong>Token enrichment</strong> - Configure Keycloak to include necessary claims in JWTs (groups, departments, attributes)</li><li><strong>Policy distribution</strong> - Establish how OPA instances receive policy updates (bundle service, git sync, CI/CD)</li><li><strong>Decision logging</strong> - Capture authorization decisions for audit and debugging</li><li><strong>Performance tuning</strong> - Cache OPA decisions appropriately for your use case</li><li><strong>Testing strategy</strong> - Unit test Rego policies independently from services</li></ol><h3 id=example-setup>Example Setup<a hidden class=anchor aria-hidden=true href=#example-setup>#</a></h3><p>A microservices environment might deploy OPA as:</p><ul><li><strong>Sidecar pattern</strong> - OPA container alongside each service</li><li><strong>Centralized service</strong> - Shared OPA cluster for all services</li><li><strong>Library integration</strong> - OPA embedded as a library in service code</li></ul><p>Each approach has trade-offs in terms of latency, consistency, and operational complexity.</p><h2 id=when-to-use-keycloak>When to Use Keycloak<a hidden class=anchor aria-hidden=true href=#when-to-use-keycloak>#</a></h2><p><strong>Keycloak is appropriate when:</strong></p><ul><li>SSO is required across multiple applications</li><li>Users exist in external systems like LDAP or Active Directory</li><li>Microservices architecture requires shared identity context</li><li>Compliance requirements demand audit trails and fine-grained permissions</li><li>Standard protocol support is needed without custom implementation</li></ul><p><strong>Consider alternatives when:</strong></p><ul><li>Building simple single applications with basic authentication needs</li><li>Preferring managed services like Auth0 or Okta over self-hosted infrastructure</li><li>Basic authentication meets all project requirements</li></ul><h2 id=understanding-identity-management-complexity>Understanding Identity Management Complexity<a hidden class=anchor aria-hidden=true href=#understanding-identity-management-complexity>#</a></h2><p>Identity management is critical infrastructure that users only notice when it fails. Keycloak addresses real authentication challenges but requires understanding of OAuth flows, token validation, and session management. The advantage lies in configuring proven software rather than building from scratch.</p><p>Teams often underestimate authentication complexity, spending months on custom systems before discovering additional protocol requirements. Conversely, some over-engineer solutions for simple use cases better served by basic authentication.</p><p>Success depends on accurately identifying your actual requirements and choosing appropriate solutions.</p><h2 id=key-considerations-for-identity-infrastructure>Key Considerations for Identity Infrastructure<a hidden class=anchor aria-hidden=true href=#key-considerations-for-identity-infrastructure>#</a></h2><p>Treating identity as infrastructure requires:</p><ul><li><strong>Scalability planning</strong> - Simple user tables quickly become inadequate</li><li><strong>Comprehensive testing</strong> - Authentication bugs represent security vulnerabilities</li><li><strong>Continuous monitoring</strong> - Track both failed and successful authentication attempts</li><li><strong>Simplicity focus</strong> - Custom integrations accumulate as technical debt</li></ul><p>Keycloak handles the complex authentication challenges that most teams shouldn&rsquo;t build themselves. Avoiding custom OAuth implementations saves significant development time and reduces security risks.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://memo.mx/posts/cloud-native-inneficiency/><span class=title>« Prev</span><br><span>The cloud native inefficiencies</span>
</a><a class=next href=https://memo.mx/posts/simplicity/><span class=title>Next »</span><br><span>Simplicity</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>