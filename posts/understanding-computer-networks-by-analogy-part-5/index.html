<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Understanding Computer Networks by Analogy: Part 5 - Follow the Envelope | Memo Garcia</title>
<meta name=keywords content><meta name=description content="License: CC BY-NC-ND 4.0
Part Five: Follow the Envelope Chapter 17: Hands-On Practice You&rsquo;ve read about buildings, cities, and hotels. Now it&rsquo;s time to explore them yourself.
This chapter contains practical exercises you can run on your own computer or in a cloud environment. Each exercise connects back to the analogies we&rsquo;ve built. You&rsquo;ll see addresses, paths, and permissions in action.
The exercises are divided into two groups. The core labs use tools available on most computers."><link rel=canonical href=https://memo.mx/posts/understanding-computer-networks-by-analogy-part-5/><meta name=google-site-verification content="G-ZRB1GGCC9B"><link crossorigin=anonymous href=/assets/css/stylesheet.d1467e28595903f993a7e37893057cefe5f69aece461c850796bf5b0a3bf422a.css integrity="sha256-0UZ+KFlZA/mTp+N4kwV87+X2muzkYchQeWv1sKO/Qio=" rel="preload stylesheet" as=style><link rel=icon href=https://memo.mx/%20favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://memo.mx/%20favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://memo.mx/%20favicon-32x32.png><link rel=apple-touch-icon href=https://memo.mx/%20apple-touch-icon.png><link rel=mask-icon href=https://memo.mx/%20safari-pinned-tab.svg><meta name=theme-color content="#0d0221"><meta name=msapplication-TileColor content="#0d0221"><link rel=alternate hreflang=en href=https://memo.mx/posts/understanding-computer-networks-by-analogy-part-5/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZRB1GGCC9B"></script><script>var dnt,doNotTrack=!1;if(!0&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZRB1GGCC9B")}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://memo.mx/posts/"},{"@type":"ListItem","position":2,"name":"Understanding Computer Networks by Analogy: Part 5 - Follow the Envelope","item":"https://memo.mx/posts/understanding-computer-networks-by-analogy-part-5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Understanding Computer Networks by Analogy: Part 5 - Follow the Envelope","name":"Understanding Computer Networks by Analogy: Part 5 - Follow the Envelope","description":"License: CC BY-NC-ND 4.0\nPart Five: Follow the Envelope Chapter 17: Hands-On Practice You\u0026rsquo;ve read about buildings, cities, and hotels. Now it\u0026rsquo;s time to explore them yourself.\nThis chapter contains practical exercises you can run on your own computer or in a cloud environment. Each exercise connects back to the analogies we\u0026rsquo;ve built. You\u0026rsquo;ll see addresses, paths, and permissions in action.\nThe exercises are divided into two groups. The core labs use tools available on most computers.","keywords":[],"articleBody":" License: CC BY-NC-ND 4.0\nPart Five: Follow the Envelope Chapter 17: Hands-On Practice You’ve read about buildings, cities, and hotels. Now it’s time to explore them yourself.\nThis chapter contains practical exercises you can run on your own computer or in a cloud environment. Each exercise connects back to the analogies we’ve built. You’ll see addresses, paths, and permissions in action.\nThe exercises are divided into two groups. The core labs use tools available on most computers. The cloud labs require access to a cloud provider account and assume basic familiarity with creating resources.\nWork through them at your own pace. When something fails, that’s often the most interesting part. Figure out what went wrong, apply the mental model, and try again.\nLab 1: Follow the Envelope with Ping and Traceroute This is your first letter to the outside world. You’ll resolve a name, check if the destination is reachable, and map the path your packets take.\nOpen a terminal. First, resolve a hostname to an IP address:\nOn macOS or Linux: dig +short example.com\nOn Windows: nslookup example.com\nThis queries the city directory. You should see one or more IP addresses.\nNext, check if you can reach that address:\nOn macOS or Linux: ping -c 5 example.com\nOn Windows: ping -n 5 example.com\nYou should see responses arriving and round-trip times. If you see timeouts, something is blocking the path.\nFinally, trace the route:\nOn macOS: traceroute example.com\nOn Linux: traceroute -n example.com\nOn Windows: tracert example.com\nEach line shows one hop. You’re watching your envelope pass from concierge to concierge across the city. Note where latency increases. Large jumps often indicate geographic distance or congestion.\nLab 2: Inspect Your Local Network Configuration Before you can leave the building, you need to know your address and where the elevator is.\nOn Linux: ip -4 addr show to see your IP and subnet mask. Then ip route to see your default gateway.\nOn macOS: ipconfig getifaddr en0 for your IP. Then netstat -nr | grep default for your gateway.\nOn Windows: ipconfig /all shows everything: IP address, subnet mask, default gateway, and DNS servers.\nNote your IP address and gateway. The gateway is the elevator lobby for your floor. Any traffic to destinations outside your subnet goes there first.\nLab 3: Watch ARP Discover MAC Addresses ARP is how your device learns the door labels (MAC addresses) for other devices on your floor.\nFirst, check your current ARP table:\nOn Linux: ip neigh\nOn macOS or Windows: arp -a\nYou’ll see IP addresses paired with MAC addresses. These are cached mappings.\nNow ping another device on your local network, something you haven’t communicated with recently. Then check the ARP table again. You should see a new entry. Your device shouted “who has this IP?” and received an answer.\nLab 4: Start a Server and Connect to a Port Ports are mail slots. Let’s open one.\nOn a machine with Python installed, start a simple web server:\npython3 -m http.server 8000\nThis opens a mail slot (port 8000) and waits for connections.\nIn another terminal, connect to it:\ncurl http://127.0.0.1:8000\nYou should see a directory listing. The curl command sent an envelope to your own machine, addressed to port 8000. The web server received it and replied.\nIf you know your machine’s LAN IP address, try connecting from another device on the same network. Whether it works depends on firewall settings.\nLab 5: Observe TCP Connections Every connection has two sockets: yours and theirs.\nMake an HTTPS request:\ncurl -I https://example.com\nWhile the connection is open (or immediately after), list your connections:\nOn Linux: ss -tnp | head\nOn macOS: netstat -anp tcp | head\nOn Windows: netstat -ano | find \":443\"\nFind the connection to example.com. Note the local port (something high, like 51234) and the remote port (443). The local port is ephemeral, assigned just for this conversation. When the connection closes, that port becomes available again.\nLab 6: Compare TCP and UDP with Netcat Netcat is a simple tool for sending data over the network.\nOpen two terminal windows. In the first, start a TCP listener:\nnc -l 9999\nIn the second, connect as a client:\nnc 127.0.0.1 9999\nType a message in the client window. It appears in the server window. TCP ensures delivery.\nNow try UDP. In the first terminal:\nnc -u -l 9998\nIn the second:\nnc -u 127.0.0.1 9998\nSend messages back and forth. Notice that there’s no connection establishment. You just start talking. If you stop and restart the server, the client keeps sending into the void. UDP doesn’t know or care.\nLab 7: Inspect a TLS Certificate Chain When you visit an HTTPS site, your browser verifies the server’s certificate. You can do this manually.\nopenssl s_client -connect example.com:443 -servername example.com -showcerts \u003c /dev/null\nThe output shows the certificate chain. Look for the subject (the site’s name), the issuer (the CA that signed it), and the validity period. The chain might have multiple certificates: the server’s certificate, one or more intermediate certificates, and implicitly the root CA that your system trusts.\nLab 8: Measure DNS Lookup Time DNS delays add to every new connection. Let’s see how long lookups take.\ndig example.com\nLook at the “Query time” in the output. This is how long the lookup took.\nRun it again. The second query is usually faster because the result is cached.\nForce a fresh lookup by asking a different DNS server:\ndig @8.8.8.8 example.com\nThis bypasses your local cache and asks Google’s DNS server directly. Compare the timing.\nLab 9: Test Maximum Packet Size Networks have a maximum transmission unit (MTU), the largest packet they can carry without fragmentation. If your packet exceeds the path MTU, it must be broken into smaller pieces, which adds overhead.\nYou can probe for the path MTU:\nOn Linux: ping -c 1 -M do -s 1472 example.com\nOn Windows: ping -f -l 1472 example.com\nThe 1472 bytes plus headers should fit in a standard 1500-byte MTU. If it works, try increasing the number. When you exceed the path MTU, you’ll get an error about fragmentation needed. The largest successful size tells you your effective MTU to that destination.\nLab 10: Measure Connection Timing When troubleshooting slow pages, it helps to know where time is spent.\ncurl -o /dev/null -s -w \"dns=%{time_namelookup} connect=%{time_connect} tls=%{time_appconnect} ttfb=%{time_starttransfer} total=%{time_total}\\n\" https://example.com\nThis breaks down the total time: DNS lookup, TCP connection, TLS handshake, time to first byte, and total. If DNS is slow, investigate your resolver. If TLS is slow, the server might be distant or overloaded. If time to first byte is slow after TLS, the application is taking time to generate the response.\nChapter 18: Cloud Labs These exercises require access to a cloud provider. The specific steps vary by provider, but the concepts are universal.\nCloud Lab A: Build a VPC with Public and Private Subnets Create a new VPC with a CIDR block like 10.0.0.0/16. This is your private floor.\nCreate two subnets. One is public (10.0.1.0/24) and one is private (10.0.2.0/24). Place them in different availability zones for resilience.\nCreate an Internet Gateway and attach it to the VPC. Update the public subnet’s route table so that traffic to 0.0.0.0/0 goes through the Internet Gateway.\nLaunch a small instance in the public subnet. Give it a public IP. Verify you can SSH to it from the internet.\nLaunch another instance in the private subnet. It has no public IP. Try to SSH to it from the internet. You can’t. Now SSH to your public instance and try to connect to the private instance from there. If security groups allow it, you can.\nYou’ve built a floor with a public wing and a private wing.\nCloud Lab B: Add a NAT Gateway Your private instances can’t reach the internet directly. But they might need to download updates.\nCreate a NAT Gateway in your public subnet. It needs an Elastic IP (a public address).\nUpdate the private subnet’s route table. Traffic to 0.0.0.0/0 should go through the NAT Gateway.\nSSH to your private instance (through the public bastion). Try to reach the internet:\ncurl https://example.com\nIt works. Your private instance can initiate outbound connections. But nobody on the internet can initiate connections to it. The NAT Gateway is the staff exit.\nCloud Lab C: Create a VPC Endpoint Your instances might access cloud storage or other provider services. By default, that traffic goes through the internet (or NAT Gateway). A VPC endpoint keeps it internal.\nCreate a gateway endpoint for your provider’s object storage service (like S3 on AWS). Associate it with your route tables.\nFrom a private instance, access the storage service. If you have flow logs enabled, you can verify the traffic doesn’t leave the VPC.\nThis is the private service door.\nCloud Lab D: Security Groups vs Network ACLs Create a web server in your public subnet. Configure its security group to allow inbound HTTP (port 80) from anywhere.\nAccess the web server from your browser. It works.\nNow add a network ACL rule to the subnet that denies inbound traffic on port 80.\nTry to access the web server again. It fails.\nRemove the NACL rule. Access is restored.\nSecurity groups are stateful (allow traffic in, and responses are automatically allowed out). NACLs are stateless (you must explicitly allow both directions). Understanding which layer blocked something is crucial for troubleshooting.\nYou’ve run the experiments. You’ve seen addresses, paths, and permissions in action. The theory has become tangible.\nOne chapter remains: the ending that circles back to the beginning.\n","wordCount":"1594","inLanguage":"en","datePublished":"2025-10-20T09:00:00-07:00","dateModified":"2025-11-30T11:38:27+09:00","author":{"@type":"Person","name":"Memo Garcia"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://memo.mx/posts/understanding-computer-networks-by-analogy-part-5/"},"publisher":{"@type":"Person","name":"Memo Garcia","logo":{"@type":"ImageObject","url":"https://memo.mx/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://memo.mx/ accesskey=h title="Memo Garcia (Alt + H)">Memo Garcia</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://memo.mx/labs/ title=Labs><span>Labs</span></a></li><li><a href=https://memo.mx/books/ title=Books><span>Books</span></a></li><li><a href=https://memo.mx/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Understanding Computer Networks by Analogy: Part 5 - Follow the Envelope</h1><div class=post-meta><span title='2025-10-20 09:00:00 -0700 -0700'>October 20, 2025</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Memo Garcia</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#part-five-follow-the-envelope aria-label="Part Five: Follow the Envelope">Part Five: Follow the Envelope</a><ul><li><a href=#chapter-17-hands-on-practice aria-label="Chapter 17: Hands-On Practice">Chapter 17: Hands-On Practice</a><ul><li><a href=#lab-1-follow-the-envelope-with-ping-and-traceroute aria-label="Lab 1: Follow the Envelope with Ping and Traceroute">Lab 1: Follow the Envelope with Ping and Traceroute</a></li><li><a href=#lab-2-inspect-your-local-network-configuration aria-label="Lab 2: Inspect Your Local Network Configuration">Lab 2: Inspect Your Local Network Configuration</a></li><li><a href=#lab-3-watch-arp-discover-mac-addresses aria-label="Lab 3: Watch ARP Discover MAC Addresses">Lab 3: Watch ARP Discover MAC Addresses</a></li><li><a href=#lab-4-start-a-server-and-connect-to-a-port aria-label="Lab 4: Start a Server and Connect to a Port">Lab 4: Start a Server and Connect to a Port</a></li><li><a href=#lab-5-observe-tcp-connections aria-label="Lab 5: Observe TCP Connections">Lab 5: Observe TCP Connections</a></li><li><a href=#lab-6-compare-tcp-and-udp-with-netcat aria-label="Lab 6: Compare TCP and UDP with Netcat">Lab 6: Compare TCP and UDP with Netcat</a></li><li><a href=#lab-7-inspect-a-tls-certificate-chain aria-label="Lab 7: Inspect a TLS Certificate Chain">Lab 7: Inspect a TLS Certificate Chain</a></li><li><a href=#lab-8-measure-dns-lookup-time aria-label="Lab 8: Measure DNS Lookup Time">Lab 8: Measure DNS Lookup Time</a></li><li><a href=#lab-9-test-maximum-packet-size aria-label="Lab 9: Test Maximum Packet Size">Lab 9: Test Maximum Packet Size</a></li><li><a href=#lab-10-measure-connection-timing aria-label="Lab 10: Measure Connection Timing">Lab 10: Measure Connection Timing</a></li></ul></li><li><a href=#chapter-18-cloud-labs aria-label="Chapter 18: Cloud Labs">Chapter 18: Cloud Labs</a><ul><li><a href=#cloud-lab-a-build-a-vpc-with-public-and-private-subnets aria-label="Cloud Lab A: Build a VPC with Public and Private Subnets">Cloud Lab A: Build a VPC with Public and Private Subnets</a></li><li><a href=#cloud-lab-b-add-a-nat-gateway aria-label="Cloud Lab B: Add a NAT Gateway">Cloud Lab B: Add a NAT Gateway</a></li><li><a href=#cloud-lab-c-create-a-vpc-endpoint aria-label="Cloud Lab C: Create a VPC Endpoint">Cloud Lab C: Create a VPC Endpoint</a></li><li><a href=#cloud-lab-d-security-groups-vs-network-acls aria-label="Cloud Lab D: Security Groups vs Network ACLs">Cloud Lab D: Security Groups vs Network ACLs</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>License: CC BY-NC-ND 4.0</p></blockquote><hr><h1 id=part-five-follow-the-envelope>Part Five: Follow the Envelope<a hidden class=anchor aria-hidden=true href=#part-five-follow-the-envelope>#</a></h1><h2 id=chapter-17-hands-on-practice>Chapter 17: Hands-On Practice<a hidden class=anchor aria-hidden=true href=#chapter-17-hands-on-practice>#</a></h2><p>You&rsquo;ve read about buildings, cities, and hotels. Now it&rsquo;s time to explore them yourself.</p><p>This chapter contains practical exercises you can run on your own computer or in a cloud environment. Each exercise connects back to the analogies we&rsquo;ve built. You&rsquo;ll see addresses, paths, and permissions in action.</p><p>The exercises are divided into two groups. The core labs use tools available on most computers. The cloud labs require access to a cloud provider account and assume basic familiarity with creating resources.</p><p>Work through them at your own pace. When something fails, that&rsquo;s often the most interesting part. Figure out what went wrong, apply the mental model, and try again.</p><hr><h3 id=lab-1-follow-the-envelope-with-ping-and-traceroute>Lab 1: Follow the Envelope with Ping and Traceroute<a hidden class=anchor aria-hidden=true href=#lab-1-follow-the-envelope-with-ping-and-traceroute>#</a></h3><p>This is your first letter to the outside world. You&rsquo;ll resolve a name, check if the destination is reachable, and map the path your packets take.</p><p>Open a terminal. First, resolve a hostname to an IP address:</p><p>On macOS or Linux: <code>dig +short example.com</code></p><p>On Windows: <code>nslookup example.com</code></p><p>This queries the city directory. You should see one or more IP addresses.</p><p>Next, check if you can reach that address:</p><p>On macOS or Linux: <code>ping -c 5 example.com</code></p><p>On Windows: <code>ping -n 5 example.com</code></p><p>You should see responses arriving and round-trip times. If you see timeouts, something is blocking the path.</p><p>Finally, trace the route:</p><p>On macOS: <code>traceroute example.com</code></p><p>On Linux: <code>traceroute -n example.com</code></p><p>On Windows: <code>tracert example.com</code></p><p>Each line shows one hop. You&rsquo;re watching your envelope pass from concierge to concierge across the city. Note where latency increases. Large jumps often indicate geographic distance or congestion.</p><hr><h3 id=lab-2-inspect-your-local-network-configuration>Lab 2: Inspect Your Local Network Configuration<a hidden class=anchor aria-hidden=true href=#lab-2-inspect-your-local-network-configuration>#</a></h3><p>Before you can leave the building, you need to know your address and where the elevator is.</p><p>On Linux: <code>ip -4 addr show</code> to see your IP and subnet mask. Then <code>ip route</code> to see your default gateway.</p><p>On macOS: <code>ipconfig getifaddr en0</code> for your IP. Then <code>netstat -nr | grep default</code> for your gateway.</p><p>On Windows: <code>ipconfig /all</code> shows everything: IP address, subnet mask, default gateway, and DNS servers.</p><p>Note your IP address and gateway. The gateway is the elevator lobby for your floor. Any traffic to destinations outside your subnet goes there first.</p><hr><h3 id=lab-3-watch-arp-discover-mac-addresses>Lab 3: Watch ARP Discover MAC Addresses<a hidden class=anchor aria-hidden=true href=#lab-3-watch-arp-discover-mac-addresses>#</a></h3><p>ARP is how your device learns the door labels (MAC addresses) for other devices on your floor.</p><p>First, check your current ARP table:</p><p>On Linux: <code>ip neigh</code></p><p>On macOS or Windows: <code>arp -a</code></p><p>You&rsquo;ll see IP addresses paired with MAC addresses. These are cached mappings.</p><p>Now ping another device on your local network, something you haven&rsquo;t communicated with recently. Then check the ARP table again. You should see a new entry. Your device shouted &ldquo;who has this IP?&rdquo; and received an answer.</p><hr><h3 id=lab-4-start-a-server-and-connect-to-a-port>Lab 4: Start a Server and Connect to a Port<a hidden class=anchor aria-hidden=true href=#lab-4-start-a-server-and-connect-to-a-port>#</a></h3><p>Ports are mail slots. Let&rsquo;s open one.</p><p>On a machine with Python installed, start a simple web server:</p><p><code>python3 -m http.server 8000</code></p><p>This opens a mail slot (port 8000) and waits for connections.</p><p>In another terminal, connect to it:</p><p><code>curl http://127.0.0.1:8000</code></p><p>You should see a directory listing. The curl command sent an envelope to your own machine, addressed to port 8000. The web server received it and replied.</p><p>If you know your machine&rsquo;s LAN IP address, try connecting from another device on the same network. Whether it works depends on firewall settings.</p><hr><h3 id=lab-5-observe-tcp-connections>Lab 5: Observe TCP Connections<a hidden class=anchor aria-hidden=true href=#lab-5-observe-tcp-connections>#</a></h3><p>Every connection has two sockets: yours and theirs.</p><p>Make an HTTPS request:</p><p><code>curl -I https://example.com</code></p><p>While the connection is open (or immediately after), list your connections:</p><p>On Linux: <code>ss -tnp | head</code></p><p>On macOS: <code>netstat -anp tcp | head</code></p><p>On Windows: <code>netstat -ano | find ":443"</code></p><p>Find the connection to example.com. Note the local port (something high, like 51234) and the remote port (443). The local port is ephemeral, assigned just for this conversation. When the connection closes, that port becomes available again.</p><hr><h3 id=lab-6-compare-tcp-and-udp-with-netcat>Lab 6: Compare TCP and UDP with Netcat<a hidden class=anchor aria-hidden=true href=#lab-6-compare-tcp-and-udp-with-netcat>#</a></h3><p>Netcat is a simple tool for sending data over the network.</p><p>Open two terminal windows. In the first, start a TCP listener:</p><p><code>nc -l 9999</code></p><p>In the second, connect as a client:</p><p><code>nc 127.0.0.1 9999</code></p><p>Type a message in the client window. It appears in the server window. TCP ensures delivery.</p><p>Now try UDP. In the first terminal:</p><p><code>nc -u -l 9998</code></p><p>In the second:</p><p><code>nc -u 127.0.0.1 9998</code></p><p>Send messages back and forth. Notice that there&rsquo;s no connection establishment. You just start talking. If you stop and restart the server, the client keeps sending into the void. UDP doesn&rsquo;t know or care.</p><hr><h3 id=lab-7-inspect-a-tls-certificate-chain>Lab 7: Inspect a TLS Certificate Chain<a hidden class=anchor aria-hidden=true href=#lab-7-inspect-a-tls-certificate-chain>#</a></h3><p>When you visit an HTTPS site, your browser verifies the server&rsquo;s certificate. You can do this manually.</p><p><code>openssl s_client -connect example.com:443 -servername example.com -showcerts &lt; /dev/null</code></p><p>The output shows the certificate chain. Look for the subject (the site&rsquo;s name), the issuer (the CA that signed it), and the validity period. The chain might have multiple certificates: the server&rsquo;s certificate, one or more intermediate certificates, and implicitly the root CA that your system trusts.</p><hr><h3 id=lab-8-measure-dns-lookup-time>Lab 8: Measure DNS Lookup Time<a hidden class=anchor aria-hidden=true href=#lab-8-measure-dns-lookup-time>#</a></h3><p>DNS delays add to every new connection. Let&rsquo;s see how long lookups take.</p><p><code>dig example.com</code></p><p>Look at the &ldquo;Query time&rdquo; in the output. This is how long the lookup took.</p><p>Run it again. The second query is usually faster because the result is cached.</p><p>Force a fresh lookup by asking a different DNS server:</p><p><code>dig @8.8.8.8 example.com</code></p><p>This bypasses your local cache and asks Google&rsquo;s DNS server directly. Compare the timing.</p><hr><h3 id=lab-9-test-maximum-packet-size>Lab 9: Test Maximum Packet Size<a hidden class=anchor aria-hidden=true href=#lab-9-test-maximum-packet-size>#</a></h3><p>Networks have a maximum transmission unit (MTU), the largest packet they can carry without fragmentation. If your packet exceeds the path MTU, it must be broken into smaller pieces, which adds overhead.</p><p>You can probe for the path MTU:</p><p>On Linux: <code>ping -c 1 -M do -s 1472 example.com</code></p><p>On Windows: <code>ping -f -l 1472 example.com</code></p><p>The 1472 bytes plus headers should fit in a standard 1500-byte MTU. If it works, try increasing the number. When you exceed the path MTU, you&rsquo;ll get an error about fragmentation needed. The largest successful size tells you your effective MTU to that destination.</p><hr><h3 id=lab-10-measure-connection-timing>Lab 10: Measure Connection Timing<a hidden class=anchor aria-hidden=true href=#lab-10-measure-connection-timing>#</a></h3><p>When troubleshooting slow pages, it helps to know where time is spent.</p><p><code>curl -o /dev/null -s -w "dns=%{time_namelookup} connect=%{time_connect} tls=%{time_appconnect} ttfb=%{time_starttransfer} total=%{time_total}\n" https://example.com</code></p><p>This breaks down the total time: DNS lookup, TCP connection, TLS handshake, time to first byte, and total. If DNS is slow, investigate your resolver. If TLS is slow, the server might be distant or overloaded. If time to first byte is slow after TLS, the application is taking time to generate the response.</p><hr><h2 id=chapter-18-cloud-labs>Chapter 18: Cloud Labs<a hidden class=anchor aria-hidden=true href=#chapter-18-cloud-labs>#</a></h2><p>These exercises require access to a cloud provider. The specific steps vary by provider, but the concepts are universal.</p><h3 id=cloud-lab-a-build-a-vpc-with-public-and-private-subnets>Cloud Lab A: Build a VPC with Public and Private Subnets<a hidden class=anchor aria-hidden=true href=#cloud-lab-a-build-a-vpc-with-public-and-private-subnets>#</a></h3><p>Create a new VPC with a CIDR block like 10.0.0.0/16. This is your private floor.</p><p>Create two subnets. One is public (10.0.1.0/24) and one is private (10.0.2.0/24). Place them in different availability zones for resilience.</p><p>Create an Internet Gateway and attach it to the VPC. Update the public subnet&rsquo;s route table so that traffic to 0.0.0.0/0 goes through the Internet Gateway.</p><p>Launch a small instance in the public subnet. Give it a public IP. Verify you can SSH to it from the internet.</p><p>Launch another instance in the private subnet. It has no public IP. Try to SSH to it from the internet. You can&rsquo;t. Now SSH to your public instance and try to connect to the private instance from there. If security groups allow it, you can.</p><p>You&rsquo;ve built a floor with a public wing and a private wing.</p><hr><h3 id=cloud-lab-b-add-a-nat-gateway>Cloud Lab B: Add a NAT Gateway<a hidden class=anchor aria-hidden=true href=#cloud-lab-b-add-a-nat-gateway>#</a></h3><p>Your private instances can&rsquo;t reach the internet directly. But they might need to download updates.</p><p>Create a NAT Gateway in your public subnet. It needs an Elastic IP (a public address).</p><p>Update the private subnet&rsquo;s route table. Traffic to 0.0.0.0/0 should go through the NAT Gateway.</p><p>SSH to your private instance (through the public bastion). Try to reach the internet:</p><p><code>curl https://example.com</code></p><p>It works. Your private instance can initiate outbound connections. But nobody on the internet can initiate connections to it. The NAT Gateway is the staff exit.</p><hr><h3 id=cloud-lab-c-create-a-vpc-endpoint>Cloud Lab C: Create a VPC Endpoint<a hidden class=anchor aria-hidden=true href=#cloud-lab-c-create-a-vpc-endpoint>#</a></h3><p>Your instances might access cloud storage or other provider services. By default, that traffic goes through the internet (or NAT Gateway). A VPC endpoint keeps it internal.</p><p>Create a gateway endpoint for your provider&rsquo;s object storage service (like S3 on AWS). Associate it with your route tables.</p><p>From a private instance, access the storage service. If you have flow logs enabled, you can verify the traffic doesn&rsquo;t leave the VPC.</p><p>This is the private service door.</p><hr><h3 id=cloud-lab-d-security-groups-vs-network-acls>Cloud Lab D: Security Groups vs Network ACLs<a hidden class=anchor aria-hidden=true href=#cloud-lab-d-security-groups-vs-network-acls>#</a></h3><p>Create a web server in your public subnet. Configure its security group to allow inbound HTTP (port 80) from anywhere.</p><p>Access the web server from your browser. It works.</p><p>Now add a network ACL rule to the subnet that denies inbound traffic on port 80.</p><p>Try to access the web server again. It fails.</p><p>Remove the NACL rule. Access is restored.</p><p>Security groups are stateful (allow traffic in, and responses are automatically allowed out). NACLs are stateless (you must explicitly allow both directions). Understanding which layer blocked something is crucial for troubleshooting.</p><hr><p>You&rsquo;ve run the experiments. You&rsquo;ve seen addresses, paths, and permissions in action. The theory has become tangible.</p><p>One chapter remains: the ending that circles back to the beginning.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=next href=https://memo.mx/posts/multi-region-series-part-7a-rollouts/><span class=title>Next »</span><br><span>Multi Region Cloud Training Lab: Part 7.1 - Progressive Delivery with Argo Rollouts</span></a></nav></footer></article></main><footer class=footer></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>