In simple terms: gateway = elevator. If you’re on Floor 1 and need to get to Floor 5, you take the elevator up. If your PC on Network A needs to send data to Network B, it sends it to the gateway (router), which then moves that data into Network B.

What’s important here is that gateways often also handle differences between networks. Imagine if Floor 1 hallways are very different from Floor 5 hallways – the elevator provides a standardized way to transition. In networking, a gateway might translate or encapsulate data when moving between dissimilar systems or protocols. For example, a gateway between an email system and a text-messaging system would translate email to SMS format. But for IP networks (which all speak IP, just different subnets), the gateway mainly just forwards IP packets from one subnet to another (possibly changing some addressing info like MAC or performing NAT if going to a different addressing scheme).

From a user perspective, the gateway is usually just an IP address configured on your device as the “route to anything not on my local network.” It’s like telling your room, “If the destination isn’t on this floor, use the elevator at IP 192.168.1.1” (which is often a home router’s IP).

So the visual: the elevator takes the message from the floor’s switch up (or down) to the destination floor’s switch. Once it arrives, the local floor manager handles it from there.
Technical Perspective: In networking, a default gateway is typically the IP address of a router interface on the local subnet that leads to other networks. For example, in a home network 192.168.1.0/24, the router might be 192.168.1.1 – that’s the default gateway for all devices in that subnet. When your computer wants to contact an IP that is not in 192.168.1.x, it sends the packet to 192.168.1.1 (the gateway). The router then routes it out towards the internet (the broader building/city). The term gateway can also mean more complex protocol translators (for instance, an email-to-SMS gateway or a voice gateway converting VoIP to traditional phone network), but in IP networking, it usually just means “the router that I send stuff to in order to reach other networks.” Gateways ensure interoperability between different network segments and often different protocols. In IP, the gateway typically operates at Layer 3, but it might also do Layer 4+ functions like NAT or firewalling as part of that role.

A bit of trivia: historically, routers were sometimes called “gateways” in older literature, which can confuse newcomers since now we use router for IP packet forwarder and gateway more as a general term or default route.

In any case, whenever you see “Default Gateway” in your network settings, think “this is the elevator I take to get out of my floor.” The gateway has one foot in your local network and another in the outside network, shuffling data between the two. If the gateway goes down, your network becomes an island – like an elevator out of order, no easy way to reach other floors until it’s fixed.
A Message’s Journey

Now that we have the cast of characters (rooms, doors, switches, routers, gateways), let’s put it all together in a short story. This will illustrate the typical path of a message inside a building-network and then beyond, tying Part 1’s concepts together.

Scenario: You are in Room 101 on Floor 1 (let’s say that’s your laptop on the Engineering subnet) and you want to send a message to Room 504 on Floor 5 (maybe your manager’s computer on a Management subnet) in the same building.

Here’s the journey step-by-step:

 Starting Point – Room 101 (You): You write the message and address it to “Room 504, Floor 5.” In networking terms, your computer prepares a data packet with destination IP belonging to the Floor 5 subnet (say 10.5.0.4 for Floor 5, vs your 10.1.0.101 on Floor 1).

 Local Floor Check – Switch on Floor 1: You hand the message to the Floor 1 switch (your network interface sends the frame to the switch). The switch looks at the destination. Room 504 is not on Floor 1, so the switch doesn’t know which port leads there. It effectively says, “This isn’t on my floor – I need to send this to the router (concierge).”

 Hand-Off to Router – Building Concierge: The Floor 1 switch forwards the packet to the router (which is configured as the gateway for Floor 1). The router, being the concierge, checks its routing table (the building map). It sees that Room 504 is on Floor 5, which it can reach via the interface connected to Floor 5’s network (it knows Floor 5 exists and how to get there).

 Routing the Message – Going up: The router encapsulates the packet appropriately for Floor 5 network and sends it out the correct interface (essentially putting it into the elevator destined for Floor 5). This is the step where the router chooses the path (in this case, straightforward – just send to Floor 5).

 Arrival at Floor 5 – Switch on Floor 5: The packet comes out on Floor 5 and is picked up by the Floor 5 switch. Now we’re back to a local scenario on that floor. The Floor 5 switch knows exactly where Room 504 is (it has learned the MAC for Room 504’s computer and which port it’s on). It delivers the message to Room 504’s door without bothering any other rooms.

 Message Received – Room 504: The computer in Room 504 receives the message you sent. Success!

If Room 504 replies to Room 101, the same sequence happens in reverse: Floor 5 switch -> router -> Floor 1 switch -> Room 101, with all the devices doing the analogous steps for the return path.

The key takeaway is that each component (room, switch, router, elevator) has a specific role and they cooperate to deliver data accurately:

 The switch ensures no unnecessary knocking on doors on a floor.

 The router ensures the message gets to the right floor/building.

 The gateway (router’s interface/elevator) actually carries it between floors.

 The addresses (floor+room numbers or IPs) ensure everyone knows where it should go.

Now, all of this was within one building (one network). What if Room 101 wanted to send a message to a room in another building entirely? Perhaps an entirely different company or someone across town? This is where we extend the analogy out to a city of buildings – which represents the wider internet beyond your local network.

(Pun time: we’ve been building up this analogy, and now it’s time to construct an entire city out of it!)

Before we move on to the city scale, let’s do a quick check: We covered how data moves around inside a network (building). We saw floors (subnets), rooms (devices), switches (floor managers), routers (concierges), and gateways (elevators) working together so that a message can travel from one room to any other room in the same building. The next step is going outside the building.

Imagine you’re in your building and you want to deliver a package to someone in another building across town. You’d need to step outside, find the address, travel through city roads, etc. That’s what happens when you send data to a different network across the internet. So let’s zoom out from one building to the entire city.
Technical Perspective: The journey described is essentially what happens when a packet travels from one host to another on a different subnet within a LAN or campus network:

 Source: The source computer sees that the destination IP is not in its own subnet, so it forwards the packet to its default gateway (router). (Your computer knows its own IP and subnet mask, so it can determine that Floor 5 IP 10.5.x.x is not local to Floor 1 10.1.x.x).

 Switching: The source’s switch uses its MAC table to send the frame to the router’s MAC (which corresponds to the gateway IP). The router’s MAC address was likely learned or provided via ARP (the source did an ARP for the gateway IP to get its MAC).

 Routing: The router receives the frame, strips it to get the IP packet, looks at the destination IP, finds the route to that network (Floor 5). It then encapsulates the packet in a new frame with the MAC of the Floor 5 destination (via ARP on Floor 5 network) and sends it out the Floor 5 interface.

 Delivery: The Floor 5 switch gets that frame and delivers it to the correct port for the destination MAC (Room 504’s computer).

 Return: For the reply, similar process: the Floor 5 machine sends to its gateway (router) since Floor 1 is different network, and the router forwards to Floor 1 network, and so on.

This sequence involves multiple layers of the OSI model working together:

 Application (your message content).

 Transport (e.g., TCP/UDP with port numbers ensuring it goes to the right application in the destination room, akin to mailboxes which we’ll discuss soon).

 Network (IP addresses getting it across networks).

 Data Link (MAC addresses and switches getting it across one network segment).

 Physical (the actual cables/elevators moving bits as signals).

The example above didn’t explicitly mention port numbers or specific protocols; it’s a generic data transfer. In coming chapters, we’ll refine the picture by adding those details (like what if it’s a web message vs an email? How do ports and protocols come in?).

The important part here is understanding the chain of devices a typical local communication goes through: host -> switch -> router -> switch -> host, and how addressing changes at each step (MAC addresses change per segment, IP addresses remain the same end-to-end in this inside-building scenario).

Alright, now let’s step outside to Part 2: the city analogy, where we talk about the internet at large and how multiple buildings (networks) connect across the world.
Private vs. Public IP Addresses

Up to now, we talked about addresses like room numbers that work fine inside your building. But if someone outside the building wants to send you a letter, “Room 101” is not enough information – they need the building’s street address. Similarly, in computer networks we have private addresses (usable within your local network/building) and public addresses (usable globally, across the internet city).

Inside your building, rooms can have numbers that are reused in other buildings with no conflict. There might be a Room 101 in Building A and also a Room 101 in Building B. As long as those buildings are separate, it’s not a problem – these are like private IP addresses which are unique within their own network, but not globally unique. Common private IP ranges (like 192.168.x.x or 10.x.x.x) are used in many networks around the world, but that’s okay because each network (building) is isolated from the others by routers.

When data needs to travel outside your network to another network, that’s like sending mail to another building. For that, you rely on a public IP address for your network – analogous to the official street address of your entire building.

 Private IP (Room Number): An address that is meaningful only within your own network (building). For instance, 192.168.1.101 might be your laptop’s private IP in your home. If you visit a friend’s house, they might also have a device at 192.168.1.101 on their network – no conflict, because your two home networks are separate “buildings.” These are like internal room number
 . They allow devices in the same network to communicate, but from outside, these addresses aren’t directly reachable.

 Public IP (Building’s Street Address): An address that is unique across the entire internet (the city). It represents your whole network when communicating with the outside world. For example, your home router might have a public IP like 203.0.113.42 assigned by your ISP. That’s the address other networks use to find your network. It’s like the delivery trucks in the city using your street address to find your buildin
 . Once a truck reaches your building, your internal staff (router & NAT) figure out which room should get the package.

How do these work together? Consider when you access a website:

 Your computer (Room 101) has a private IP. You type a website address, your computer’s request is sent to your home router (the building concierge).

 Your router has a public IP (the building’s address). It forwards your request out to the internet with its public “return address.” The outside world only sees the router’s public IP as the source of the request, not your PC’s private IP (which wouldn’t mean anything to them).

 When the response comes back from the website’s server, it comes addressed to your router’s public IP (your building). Your router then delivers it internally to the correct device (room) that requested it. This is achieved by something called NAT (Network Address Translation), which we’ll detail soon. For now, think of NAT as the building’s mailroom sorting incoming mail to the right room since externally everything was addressed just to the building.

In summary:

 Private IP = your room number (internal address) that only matters inside your building’s network. For example, “Room 101” or “Device 192.168.1.101” – fine within your own network, but not unique in the whole city.

 Public IP = your building’s official street address (external address) known to the whole world outside. For example, “123 Main St.” or “203.0.113.42”. That’s how other networks find your building to send data to i

When you’re within a private network and you want to reach the internet, you go through a gateway that translates your private address to the public address of the network (like using the building’s return address for all outgoing mail). Conversely, any incoming data from outside is addressed to the public IP (the building), and then routed internally to the correct private IP (the room).

This separation is crucial for both practicality and security:

 Practically, it conserves the limited IPv4 address space. We can reuse private address ranges in millions of networks without collision, and only the gateways need a unique public IP.

 Security-wise, it provides a basic firewall – outside devices can’t directly initiate a connection to an internal private IP because they don’t have a direct address for it (it’s like not knowing someone’s extension number, you only know the main line). The router, by default, won’t forward unexpected incoming traffic to a private IP unless configured to (which provides some protection – your devices are not directly exposed).

We’ll dive more into the mechanism (NAT) in a later chapter. But it’s important to realize that your computer likely has two IP addresses in play: one that it knows (private) and one that the rest of the world sees (the public IP of your router). This is analogous to how you might have an internal phone extension at work, but people outside call the main number and the receptionist (router) connects them to you.

One more note: Not all networks require NAT. Businesses or servers can have public IPs assigned directly to devices (like having a building with a unique street address for every office – IPv6 will actually allow that easily since there are plenty of addresses). But with IPv4, public addresses are scarce, so NAT became very common.
Technical Perspective: IP address classes and private ranges: The concept of private vs public IP addresses is defined by standards (RFC 1918 for IPv4 private ranges). The private IPv4 ranges are:

 10.0.0.0 – 10.255.255.255 (a 10.x.x.x block, 16 million addresses possible – often used in large orgs),

 172.16.0.0 – 172.31.255.255 (16 blocks of 65k addresses each – medium networks),

 192.168.0.0 – 192.168.255.255 (256 blocks of 256 addresses – very common in home networks).
 These addresses are not routable on the public internet – internet routers will not forward packets with these addresses as source or destination. That’s why they are free to reuse internally.

A public IP is one that isn’t in those private ranges (and isn’t otherwise reserved) and can be reached from the internet. They are assigned by regional internet registries to ISPs and organizations. For example, your ISP might have a pool of public IPs and assign one to your home router (either dynamically via DHCP or statically).

NAT (Network Address Translation): Typically implemented in your router, NAT will swap the source IP (and port) of outbound packets from private to public, and maintain a table to do the reverse when responses come i
. We have a full chapter on NAT analogies later, but technically it’s how multiple devices share one public IP. NAT has some side effects – e.g., a server on a private IP can’t be directly contacted from outside unless the router is configured to forward certain ports to it (port forwarding). NAT also breaks the end-to-end connectivity principle, which was one impetus for IPv6 adoption (so every device can have a public IP again). But NAT does act as a basic firewall since inbound is blocked unless explicitly allowed.

Private vs Public usage: Usually, your personal devices have private IPs (e.g., 192.168.1.x at home), and your router’s WAN interface has a public IP from the ISP (unless even your ISP does carrier-grade NAT, which some mobile networks do). When you go to memo.mx (with IP say 203.0.113.5), your PC (192.168.1.100) sends to router (192.168.1.1), router NATs it out as (203.0.113.42 source, for example), the server replies to 203.0.113.42, router gets it and NATs back to 192.168.1.100. All behind the scenes.

Security: While NAT prevents unsolicited inbound, it’s not a full security measure—firewalls are still needed for more granular control. But it’s true that a device on a private IP is a bit less exposed than one with a public IP (unless the router is configured to expose it). This is one reason home devices aren’t directly hackable from internet unless you misconfigure the router or the device initiates something malicious.

So, private vs public IP is essentially local vs global addressing. Think of private IP as your inside identity and public IP as your outside identity. The mapping between them is handled by your network’s gateway through NAT. This dual system allowed the internet to grow beyond the hard limit of ~4 billion IPv4 addresses by reusing the internal ranges in countless networks.
DNS: The Public Directory

Continuing our city analogy: suppose you want to send a letter to "Hotel Sunrise" in another city, but you don’t know its street address. You’d look it up in a directory or phone book. In networking, when you have a name like memo.mx or google.com but you need the numeric IP address to actually send data, you use DNS.

DNS (Domain Name System) is like the *public directory for the internet
. It’s essentially the phone book or address book that maps human-friendly names to IP addresses. Humans are good at remembering names (“Hotel Sunrise” or “memo.mx”), whereas computers route information using numbers (IP addresses). DNS bridges that gap by translating names to numbers.

How does it work in our analogy?

 Each building on the internet may register its name in a global directory service (DNS). For example, “memo.mx” is a name registered in DNS, and it corresponds to a certain IP address (like the building’s street address).

 When your computer wants to send data to memo.mx, it doesn’t know what numeric address to send to at first. It essentially asks DNS, “What’s the address of the building named memo.mx?” This is like looking up a company’s address in a phone book because you only know the company name.

 DNS servers around the world collaborate to maintain this directory. Your computer or local network will query a DNS server (often provided by your ISP or a public service like 1.1.1.1 or 8.8.8.8). If that server doesn’t know the answer, it will go up the chain (to root servers, then to MX domain servers, etc.) to find who is authoritative for that name.

 Eventually, you get an answer: “memo.mx is at 203.0.113.5” (for example). Now your computer has the building’s address and can proceed to send the data there.

 This process is usually invisible and fast (it can take just a few milliseconds as DNS is optimized with caching). It’s like having a super-efficient global phonebook that everyone can consult in an automated way.

Another analogy: DNS is like calling directory assistance. You provide a name, and the service responds with a number. In fact, DNS is often called the “phone book of the internet. Without it, we’d be stuck memorizing IP addresses or maintaining our own lists.

A bit more depth on how the DNS directory is structured:

 It’s hierarchical, much like phone books might be organized by country and city. At the top are root servers (they handle the very top-level: they know where to find the servers for top-level domains like .com, .mx, .org, etc.).

 For a name like memo.mx, your DNS resolver would first ask a root server, “where can I find information about .mx domains?” The root would respond with the address of the .mx TLD name servers (the directory for .mx).

 Then the resolver asks one of those, “where can I find the server for memo.mx domain?” The .mx server replies with the address of the authoritative name server for memo.mx (maybe Memo’s own DNS server or the provider’s).

 Finally, that authoritative server is asked, “what’s the IP for memo.mx?” and it gives the answer (203.0.113.5, for example).

 This sounds like a lot, but it’s distributed and cached. Typically, your local DNS resolver will have some info cached (like it may know the .mx servers already, etc.). And once it learns memo.mx’s IP, it will cache that so next time it doesn’t need to repeat the whole process (at least until the cache expires).

So effectively, DNS acts like a giant, distributed directory assistance for the internet. Instead of you memorizing an IP like 142.250.64.78, you just remember google.com and DNS does the rest. It’s so integral that most network applications automatically use DNS under the hood to translate names to addresses.

If you recall our earlier private vs public IP discussion: we said you often access things by name, not by number, and DNS is why that works. It’s also flexible: if a website changes its server IP, they just update DNS – users keep using the same name and hardly notice anything changed.

One more layer of analogy: think of DNS like having not just a phone book, but a whole chain of directory services: local (your OS cache), then your ISP’s (regional directory), then the global root/TLD (the “international directory”). This multi-tiered approach ensures that queries are resolved efficiently and the system can scale to millions of names.
Technical Perspective: DNS (Domain Name System) is a decentralized naming system for devices/services. When you type a hostname (like example.com), a DNS resolver breaks it down:

 Root query: It contacts a root server (there are 13 root server clusters globally, serving the root zone). The root server responds with referrals to TLD name servers (e.g., for .com).

 TLD query: It contacts the TLD server for .mx, which responds with the authoritative name server for memo.mx (the NS record, basically “ask that server”).

 Authoritative query: It then contacts that authoritative server which finally returns the IP (the A record for IPv4, or AAAA record for IPv6.

 Caching: Each step’s result is cached by your resolver (and often by your local OS). So subsequent lookups for the same name (or even same TLD) can skip earlier steps for a while (controlled by DNS record TTLs).

Your computer typically doesn’t do the full recursion; it asks a recursive resolver (often at your ISP or a public one like Google’s 8.8.8.8 or Cloudflare’s 1.1.1.1). That resolver does the above steps (root -> TLD -> auth) and returns the answer to your computer, then caches it for other. If next time some other user asks for the same hostname, the resolver can reply immediately from cache.

DNS queries usually use UDP on port 53 (since the query/response are small), falling back to TCP for larger responses (like DNS zone transfers or very long records). Modern DNS has extensions and even encryption (DNS over HTTPS/TLS) to address privacy and security, but the basic concept remains mapping names to addresses.

It’s not just IP addresses: DNS also stores other info, like MX records (mail server for a domain), TXT records (text info, often for verification/keys), CNAME (alias from one name to another), etc. But the A/AAAA record (name to IP) is the most fundamental for general browsing.

Without DNS, the internet as we know it would be very user-unfriendly (imagine sharing a website by saying “go to 142.251.32.110” instead of “go to google.com”). It also decouples the service location from its name – servers can move IPs, and DNS updates keep the name working for users. It’s like a dynamic phone book that can update entries as needed.

One can appreciate that while DNS is like a “phonebook,” it’s much faster and automated than a human-accessed phonebook – usually resolving names in a fraction of a second, and it handles billions of queries per day across the world.

So, DNS is our public directory service, ensuring that when we use human-friendly names, the network can still route to the correct numeric addresse
. It’s a behind-the-scenes hero of internet usability.
TCP vs. UDP

Now let’s shift gears a bit. We’ve been focusing on addresses and delivery, which is like ensuring the mail gets to the right building and room. But what about how the messages themselves are sent and received? In networking, two major “delivery services” govern how data packets get transported: TCP and UDP. Think of them as two different mailing services with their own policies about delivery guarantees and speed.

Using our analogy: when you send a package or a letter, you have options. You could send it registered mail – where the postal service ensures it gets to the recipient and you get a confirmation receipt, and if it’s lost, they try to resend. Or you could drop it in a mailbox with a regular stamp without tracking – it’s simpler and usually fine, but you won’t know if it arrived, and there’s no automatic retry. That’s the difference between TCP and UDP in a nutshell.

 TCP (Transmission Control Protocol) – Reliable Registered Mail:
 TCP is like using a reliable courier or certified mail servic
 . When you send data over TCP, the protocol establishes a connection (like a handshake agreement) and ensures that every packet of data is received and acknowledged by the other side. If something gets lost along the way, TCP will detect that (because it won’t get an acknowledgment for that packet) and resend it. It’s as if every letter you send requires the recipient to sign a receipt and send it back to you. If the receipt doesn’t come, you send another copy of the letter. This makes TCP reliable – data will arrive intact and in order, or if not, the sender will know and can retr
 . The trade-off is that this back-and-forth (acknowledgments, possible resending, and ordering) adds overhead and can slow things down a bit, especially if there’s any loss or delay. It’s like how certified mail is slower and a bit more effort than just dropping letters in the mailbox. TCP is great when you need accuracy – for example, loading a webpage, transferring a file, or sending an email. You don’t want missing pieces or scrambled order in those. TCP provides features like sequencing (so packets reassemble in correct order) and error checking.

 UDP (User Datagram Protocol) – Quick Regular Mail:
 UDP is like sending a postcard or a standard letter with no trackin
 . You write it, send it, and assume it will get there, but you don’t get a confirmation. If it gets lost, you might not know unless the recipient tells you they didn’t get it (and then you’d have to decide to resend manually). UDP is thus unreliable in the sense that it doesn’t guarantee delivery or order. However, it is very lightweight – there’s no establishment of connection, no ongoing acknowledgments, no built-in retransmission. It’s basically fire-and-forget. This makes it fast and with lower latency overhead. UDP is useful when you value speed over absolute reliability, or when the application can handle any necessary error correction itself. Classic examples are live audio or video streaming, and online gaming. In a live video call, if a packet is lost, by the time you notice, that moment of audio/video is already in the past – there’s no point asking for a resend because it would arrive too late to be useful. It’s better to tolerate a bit of static or a skipped video frame and keep going in real-time. UDP suits that use case because it doesn’t wait for acknowledgments – it keeps sending the next packets. Similarly, DNS queries use UDP typically – if a query packet is lost, the application (the DNS resolver) will just send another query; we don’t need TCP’s heavy machinery for such a small transaction.

To summarize in analogy terms:

 TCP is like registered mail – you get a confirmation for every packet delivered and the mail service will retry if needed. It’s reliable but has extra steps (handshakes, receipts) that can slow things down slightl

 UDP is like standard mail – you send it off and assume it gets there. There’s no built-in recovery if it doesn’t, but it’s simple and fast, and often it’s good enough.

Let’s illustrate with a scenario: sending a multi-page document:

 If you use TCP, it’s as if you number each page, send them one by one, and after each page the recipient sends a note back “Got page 5” etc. If the recipient notices a page is missing (number 7 didn’t arrive), or you don’t get confirmation, you resend that page. In the end, the recipient can collate all pages 1 through N in order.

 If you use UDP, you just stuff all the pages into envelopes and send them out. You don’t wait to hear back. If the recipient finds page 7 missing, they can either request the whole thing again or just live with a gap. UDP itself doesn’t have a mechanism to request “just resend page 7” (that would have to be handled by the application if needed).

Most of the core internet applications in the early days (like web, email, file transfer) chose TCP because integrity was more important than speed. But as we started doing more live media and interactive stuff, UDP became crucial for those real-time applications.

One more aspect: with TCP, because it ensures ordering, if packet #7 is delayed, packet #8 will wait even if it arrived, until 7 is delivered – similar to how a conveyor belt might pause until a missing item is put back in sequence. This can introduce delay (buffering) if some packets are slow. UDP doesn’t have this issue; packet #8 just gets processed immediately even if 7 is missing (you’ll just have a gap for 7).

Neither is “better” universally; they serve different needs:

 Use TCP when you need reliability and in-order delivery (web pages, file downloads, financial transactions, etc.).

 Use UDP when you need speed and can tolerate some loss (live streams, VoIP, online games, or simple query/response where you’ll handle retry at application if needed).

Technical Perspective: TCP and UDP are transport layer protocols on top of IP:

 TCP (Connection-oriented): Before sending data, TCP performs a three-way handshake (SYN, SYN-ACK, ACK) between client and server to establish a connectio
 . This is like both parties agreeing “we’re going to have a conversation”. Once established, TCP ensures reliable delivery: it numbers bytes with sequence numbers, the receiver sends back acknowledgments (ACKs) for data received. If sender doesn’t get an ACK for some data in a certain time, it assumes it was lost and retransmits it. TCP also ensures data is delivered in the order sent and with no duplicates (it will reorder if needed and discard duplicates). It provides flow control (so a fast sender doesn’t overwhelm a slow receiver) using a window mechanism, and congestion control (so it doesn’t overload the network) by algorithms like AIMD (Additive Increase Multiplicative Decrease), slow start, etc. All these features make TCP robust and fair but add overhead and complexity. Each TCP segment carries sequence numbers, ACK numbers, flags, etc., and establishing a connection plus error recovery can add latency. Maximum throughput of a single TCP flow can also be influenced by round-trip time and packet loss (because of how congestion control works).

 UDP (Connectionless): UDP just sends independent packets called datagrams. There’s no handshake, no acknowledgment, no built-in ordering. A UDP header is very small: just 4 fields (source port, dest port, length, checksum). If packets are lost, UDP itself doesn’t detect or correct it (the receiving application might notice missing data in its own context, but UDP won’t resend). If packets arrive out of order, UDP doesn’t reorder them (again, application can handle if it cares). The upside is minimal overhead: no waiting for ACKs, no keeping track of lots of state. This is ideal for simple query-response protocols like DNS (one small question, one small answer – doing a whole TCP handshake for that would be overkill and slower
 reddit.com
 , or for streaming where continuous sending matters more than perfect delivery. Applications using UDP often implement their own reliability mechanisms if needed (e.g., some video protocols may request a key frame if too many packets were lost, or games might have their own sequence numbers for game state updates but choose to ignore old ones).

 Ports: Both TCP and UDP use port numbers to allow multiple conversations on one host (we’ll talk about ports more soon). For instance, TCP port 80 is typically HTTP web server. UDP port 53 is DNS.

 Because TCP provides a stream abstraction, the application just sees a continuous stream of bytes as if it was a direct pipe to the other end. UDP preserves message boundaries (each datagram is delivered as a discrete packet to the application).

 Examples:

